import time
from collections import deque
from typing import Dict, List
import importlib
import chromadb
from chromadb.utils import embedding_functions
from Config import Config

class TaskManagementSystem:
    def __init__(self, primary_objective=None, initial_task=None):
        self.CFG = Config()
        self.primary_objective = self.CFG.OBJECTIVE if primary_objective == None else primary_objective
        self.initial_task = self.CFG.INITIAL_TASK if initial_task == None else initial_task
        # Import the providers dynamically
        ai_module = importlib.import_module(f"provider.{self.CFG.AI_PROVIDER}")
        if self.CFG.AI_PROVIDER == "openai":
            self.embedding_function = embedding_functions.OpenAIEmbeddingFunction(api_key=self.CFG.OPENAI_API_KEY)
        else:
            self.embedding_function = embedding_functions.InstructorEmbeddingFunction(model_name="hkunlp/instructor-xl")
        # Create Chroma collection
        self.chroma_persist_dir = "memories"
        self.chroma_client = chromadb.Client(
            settings=chromadb.config.Settings(
                chroma_db_impl="duckdb+parquet",
                persist_directory=self.chroma_persist_dir,
            )
        )
        self.collection = self.chroma_client.get_or_create_collection(
            name="table_name",
            metadata={"hnsw:space": "cosine"},
            embedding_function=self.embedding_function,
        )
        # Instantiate AI Provider and get instruct method
        self.ai_instance = ai_module.AIProvider()
        self.instruct = self.ai_instance.instruct

        # Print OBJECTIVE
        print("\033[94m\033[1m" + "\n*****OBJECTIVE*****\n" + "\033[0m\033[0m")
        print(f"{primary_objective}")

        print("\033[93m\033[1m" + "\nInitial task:" + "\033[0m\033[0m" + f" {initial_task}")

        # Task list
        self.task_list = deque([])
        self.output_list = []
    
    def print_output(self, message, event_name):
        print(message)
        self.output_list.append(message)

    def add_task(self, task: Dict):
        self.task_list.append(task)

    def ai_call(self, prompt: str):
        while True:
            try:
                response = self.instruct(prompt)
                self.print_output(response, 'ai_response')
                return response
            except Exception as e:
                error_message = f"Error: {e}"
                self.print_output(error_message, 'ai_response')
                time.sleep(10)  # Wait 10 seconds and try again

    def get_prompt(self, prompt_name: str):
        with open(f"model-prompts/{self.CFG.AI_MODEL}/{prompt_name}.txt", "r") as f:
            prompt = f.read()
        return prompt

    def task_creation_agent(self, objective: str, result: Dict, task_description: str, task_list: List[str]):
        prompt = self.get_prompt("task")
        prompt = prompt.replace("{objective}", objective)
        prompt = prompt.replace("{result}", str(result))
        prompt = prompt.replace("{task_description}", task_description)
        prompt = prompt.replace("{tasks}", ", ".join(task_list))
        response = self.ai_call(prompt)
        new_tasks = response.split("\n") if "\n" in response else [response]
        return [{"task_name": task_name} for task_name in new_tasks]

    def prioritization_agent(self, this_task_id: int):
        task_names = [t["task_name"] for t in self.task_list]
        next_task_id = int(this_task_id) + 1
        prompt = self.get_prompt("priority")
        prompt = prompt.replace("{objective}", self.primary_objective)
        prompt = prompt.replace("{next_task_id}", str(next_task_id))
        prompt = prompt.replace("{task_names}", ", ".join(task_names))
        response = self.ai_call(prompt)
        new_tasks = response.split("\n") if "\n" in response else [response]
        self.task_list = deque()
        for task_string in new_tasks:
            task_parts = task_string.strip().split(".", 1)
        if len(task_parts) == 2:
            task_id = task_parts[0].strip()
            task_name = task_parts[1].strip()
            self.task_list.append({"task_id": task_id, "task_name": task_name})

    def execution_agent(self, objective: str, task: str) -> str:
        # Executes a task based on the given objective and previous context.
        #   objective: The objective or goal for the AI to perform the task.
        #   task: The task to be executed by the AI.
        # Returns: The response generated by the AI for the given task.
        context = self.context_agent(query=objective, top_results_num=5)
        prompt = self.get_prompt("execute")
        prompt = prompt.replace("{objective}", objective)
        prompt = prompt.replace("{task}", task)
        prompt = prompt.replace("{context}", str(context))
        return self.ai_call(prompt)

    def context_agent(self, query: str, top_results_num: int):
        # Retrieves context for a given query from an index of tasks.
        #   query: The query or objective for retrieving context.
        #   top_results_num: The number of top results to retrieve.
        # Returns: A list of tasks as context for the given query, sorted by relevance.
        count = self.collection.count()
        if count == 0:
            return []
        results = self.collection.query(
            query_texts=query, n_results=min(top_results_num, count), include=["metadatas"]
        )
        return [item["task"] for item in results["metadatas"][0]]

    def run(self):
        # Add the first task
        first_task = {"task_id": 1, "task_name": self.initial_task}
        self.add_task(first_task)

        # Main loop
        task_id_counter = 1
        while True:
            if self.task_list:
                # Print the task list
                print("\033[95m\033[1m" + "\n*****TASK LIST*****\n" + "\033[0m\033[0m")
                for t in self.task_list:
                    task_id = t["task_id"]
                    task_name = t["task_name"]
                    print(f"{task_id}: {task_name}")

                # Step 1: Pull the first task
                task = self.task_list.popleft()
                this_task_id = int(task["task_id"])
                this_task_name = task["task_name"]
                print("\033[92m\033[1m" + "\n*****NEXT TASK*****\n" + "\033[0m\033[0m")
                print(f"{this_task_id}: {this_task_name}")

                # Send to execution function to complete the task based on the context
                result = self.execution_agent(self.primary_objective, task["task_name"])
                print("\033[93m\033[1m" + "\n*****TASK RESULT*****\n" + "\033[0m\033[0m")
                print(result)

                # Step 2: Enrich result and store in vector db
                enriched_result = {
                    "data": result
                } # This is where you should enrich the result if needed
                result_id = f"result_{this_task_id}"
                vector = enriched_result[
                    "data"
                ]  # extract the actual result from the dictionary

                if (len(self.collection.get(ids=[result_id], include=[])["ids"]) > 0):  # Check if the result already exists
                    self.collection.update(
                        ids=result_id,
                        documents=vector,
                        metadatas={"task": task["task_name"], "result": result},
                    )
                else:
                    self.collection.add(
                        ids=result_id,
                        documents=vector,
                        metadatas={"task": task["task_name"], "result": result},
                    )

                # Step 3: Create new tasks and reprioritize task list
                new_tasks = self.task_creation_agent(
                    self.primary_objective,
                    enriched_result,
                    this_task_name,
                    [t["task_name"] for t in self.task_list],
                )

                for new_task in new_tasks:
                    task_id_counter += 1
                    new_task.update({"task_id": task_id_counter})
                    self.add_task(new_task)
                self.prioritization_agent(this_task_id)

            time.sleep(1)  # Sleep before checking the task list again
