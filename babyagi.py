import time
from collections import deque
from typing import Dict, List
from Config import Config
from SuperPrompter import SuperPrompter
class babyagi:
    def __init__(self, primary_objective=None, initial_task=None):
        self.CFG = Config()
        self.primary_objective = self.CFG.OBJECTIVE if primary_objective == None else primary_objective
        self.initial_task = self.CFG.INITIAL_TASK if initial_task == None else initial_task
        with open(f"model-prompts/{self.CFG.AI_MODEL}/execute.txt", "r") as f:
            self.execute_prompt = f.read()
        with open(f"model-prompts/{self.CFG.AI_MODEL}/task.txt", "r") as f:
            self.task_prompt = f.read()
        with open(f"model-prompts/{self.CFG.AI_MODEL}/priority.txt", "r") as f:
            self.priority_prompt = f.read()
        # Task list
        self.task_list = deque([])
        self.output_list = []
        self.prompter = SuperPrompter()

        # Print OBJECTIVE
        print("\033[94m\033[1m" + "\n*****OBJECTIVE*****\n" + "\033[0m\033[0m")
        print(f"{primary_objective}")
        print("\033[93m\033[1m" + "\nInitial task:" + "\033[0m\033[0m" + f" {initial_task}")

    def task_creation_agent(self, objective: str, result: Dict, task_description: str, task_list: List[str]):
        prompt = self.task_prompt
        prompt = prompt.replace("{objective}", objective)
        prompt = prompt.replace("{result}", str(result))
        prompt = prompt.replace("{task_description}", task_description)
        prompt = prompt.replace("{tasks}", ", ".join(task_list))
        response = self.prompter.run(prompt)
        new_tasks = response.split("\n") if "\n" in response else [response]
        return [{"task_name": task_name} for task_name in new_tasks]

    def prioritization_agent(self, this_task_id: int):
        task_names = [t["task_name"] for t in self.task_list]
        next_task_id = int(this_task_id) + 1
        prompt = self.priority_prompt
        prompt = prompt.replace("{objective}", self.primary_objective)
        prompt = prompt.replace("{next_task_id}", str(next_task_id))
        prompt = prompt.replace("{task_names}", ", ".join(task_names))
        response = self.prompter.run(prompt)
        new_tasks = response.split("\n") if "\n" in response else [response]
        self.task_list = deque()
        for task_string in new_tasks:
            task_parts = task_string.strip().split(".", 1)
        if len(task_parts) == 2:
            task_id = task_parts[0].strip()
            task_name = task_parts[1].strip()
            self.task_list.append({"task_id": task_id, "task_name": task_name})

    def execution_agent(self, objective: str, task: str) -> str:
        # Executes a task based on the given objective and previous context.
        #   objective: The objective or goal for the AI to perform the task.
        #   task: The task to be executed by the AI.
        # Returns: The response generated by the AI for the given task.
        context = self.prompter.context_agent(query=objective, top_results_num=5)
        prompt = self.execute_prompt
        prompt = prompt.replace("{objective}", objective)
        prompt = prompt.replace("{task}", task)
        prompt = prompt.replace("{context}", str(context))
        return self.prompter.run(prompt)

    def run(self):
        # Add the first task
        first_task = {"task_id": 1, "task_name": self.initial_task}
        self.task_list.append(first_task)

        # Main loop
        task_id_counter = 1
        while True:
            if self.task_list:
                # Print the task list
                print("\033[95m\033[1m" + "\n*****TASK LIST*****\n" + "\033[0m\033[0m")
                for t in self.task_list:
                    task_id = t["task_id"]
                    task_name = t["task_name"]
                    print(f"{task_id}: {task_name}")

                # Step 1: Pull the first task
                task = self.task_list.popleft()
                this_task_id = int(task["task_id"])
                this_task_name = task["task_name"]
                print("\033[92m\033[1m" + "\n*****NEXT TASK*****\n" + "\033[0m\033[0m")
                print(f"{this_task_id}: {this_task_name}")

                # Send to execution function to complete the task based on the context
                result = self.execution_agent(self.primary_objective, task["task_name"])
                print("\033[93m\033[1m" + "\n*****TASK RESULT*****\n" + "\033[0m\033[0m")
                print(result)

                # Step 2: Enrich result and store in vector db
                enriched_result = {
                    "data": result
                } # This is where you should enrich the result if needed
                result_id = f"result_{this_task_id}"
                vector = enriched_result[
                    "data"
                ]  # extract the actual result from the dictionary
                # Store the result in the vector database
                self.store_result(task_name=this_task_name, result_id=result_id, vector=vector)

                # Step 3: Create new tasks and reprioritize task list
                new_tasks = self.task_creation_agent(
                    self.primary_objective,
                    enriched_result,
                    this_task_name,
                    [t["task_name"] for t in self.task_list],
                )

                for new_task in new_tasks:
                    task_id_counter += 1
                    new_task.update({"task_id": task_id_counter})
                    self.task_list.append(new_task)
                self.prioritization_agent(this_task_id)

            time.sleep(1)  # Sleep before checking the task list again
